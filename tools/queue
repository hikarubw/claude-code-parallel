#!/bin/bash
# Queue management tool for subissue-based worker pool system

QUEUE_DIR="$HOME/.claude/workers"
QUEUE_FILE="$QUEUE_DIR/queue.txt"
COMPLETED_FILE="$QUEUE_DIR/completed.txt"
FAILED_FILE="$QUEUE_DIR/failed.txt"
LOCK_FILE="$QUEUE_DIR/queue.lock"

# Ensure queue directory exists
mkdir -p "$QUEUE_DIR"

# Initialize queue files if they don't exist
[ ! -f "$QUEUE_FILE" ] && touch "$QUEUE_FILE"
[ ! -f "$COMPLETED_FILE" ] && touch "$COMPLETED_FILE"
[ ! -f "$FAILED_FILE" ] && touch "$FAILED_FILE"

# Acquire lock for queue operations
acquire_lock() {
    local timeout=${1:-10}
    local count=0
    while [ -f "$LOCK_FILE" ] && [ $count -lt $timeout ]; do
        sleep 1
        ((count++))
    done
    if [ $count -eq $timeout ]; then
        echo "Error: Could not acquire queue lock after $timeout seconds"
        return 1
    fi
    echo $$ > "$LOCK_FILE"
}

# Release lock
release_lock() {
    rm -f "$LOCK_FILE"
}

# Add item to queue
# Format: PRIORITY|PARENT_ISSUE|SUBISSUE_ID|STATUS|ASSIGNED_TO|CREATED_AT
queue_add() {
    local priority="$1"
    local parent_issue="$2"
    local subissue_id="$3"
    local status="${4:-pending}"
    local assigned_to="${5:-}"
    local created_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    
    if [ -z "$priority" ] || [ -z "$parent_issue" ] || [ -z "$subissue_id" ]; then
        echo "Usage: queue add PRIORITY PARENT_ISSUE SUBISSUE_ID [STATUS] [ASSIGNED_TO]"
        return 1
    fi
    
    acquire_lock || return 1
    echo "${priority}|${parent_issue}|${subissue_id}|${status}|${assigned_to}|${created_at}" >> "$QUEUE_FILE"
    release_lock
    
    echo "‚úÖ Added subissue #$subissue_id to queue (priority: $priority)"
}

# Get next item from queue
queue_next() {
    local worker_id="${1:-}"
    
    acquire_lock || return 1
    
    # Get highest priority pending item
    local next_item=$(grep "|pending||" "$QUEUE_FILE" 2>/dev/null | sort -t'|' -k1,1n | head -1)
    
    if [ -z "$next_item" ]; then
        release_lock
        return 1
    fi
    
    # Extract subissue ID
    local subissue_id=$(echo "$next_item" | cut -d'|' -f3)
    
    # Update status to working and assign to worker
    local temp_file=$(mktemp)
    awk -F'|' -v sid="$subissue_id" -v wid="$worker_id" '
        $3 == sid && $4 == "pending" {
            $4 = "working"
            $5 = wid
            print $1"|"$2"|"$3"|"$4"|"$5"|"$6
            next
        }
        {print}
    ' "$QUEUE_FILE" > "$temp_file"
    
    mv "$temp_file" "$QUEUE_FILE"
    release_lock
    
    echo "$next_item"
}

# Update item status
queue_update() {
    local subissue_id="$1"
    local status="$2"
    local worker="${3:-}"
    
    if [ -z "$subissue_id" ] || [ -z "$status" ]; then
        echo "Usage: queue update SUBISSUE_ID STATUS [WORKER]"
        return 1
    fi
    
    acquire_lock || return 1
    
    local temp_file=$(mktemp)
    local found=false
    
    while IFS='|' read -r priority parent sid current_status assigned created; do
        if [ "$sid" = "$subissue_id" ]; then
            found=true
            if [ "$status" = "completed" ]; then
                # Move to completed file
                echo "${priority}|${parent}|${sid}|${status}|${worker}|${created}|$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "$COMPLETED_FILE"
            elif [ "$status" = "failed" ]; then
                # Move to failed file
                echo "${priority}|${parent}|${sid}|${status}|${worker}|${created}|$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "$FAILED_FILE"
            else
                # Update in queue
                echo "${priority}|${parent}|${sid}|${status}|${worker:-$assigned}|${created}" >> "$temp_file"
            fi
        else
            echo "${priority}|${parent}|${sid}|${current_status}|${assigned}|${created}" >> "$temp_file"
        fi
    done < "$QUEUE_FILE"
    
    if [ "$found" = true ]; then
        mv "$temp_file" "$QUEUE_FILE"
        echo "‚úÖ Updated subissue #$subissue_id to $status"
    else
        rm "$temp_file"
        echo "‚ùå Subissue #$subissue_id not found in queue"
    fi
    
    release_lock
}

# Show queue status
queue_status() {
    echo "üìä Queue Status"
    echo "=============="
    
    local pending=$(grep -c "|pending||" "$QUEUE_FILE" 2>/dev/null || echo 0)
    local working=$(grep -c "|working|" "$QUEUE_FILE" 2>/dev/null || echo 0)
    local completed=$(wc -l < "$COMPLETED_FILE" 2>/dev/null || echo 0)
    local failed=$(wc -l < "$FAILED_FILE" 2>/dev/null || echo 0)
    
    echo "Pending:   $pending"
    echo "Working:   $working"
    echo "Completed: $completed"
    echo "Failed:    $failed"
    echo ""
    
    if [ "$pending" -gt 0 ] || [ "$working" -gt 0 ]; then
        echo "Active Queue:"
        echo "Priority | Parent | Subissue | Status | Worker"
        echo "---------|--------|----------|---------|-------"
        sort -t'|' -k1,1n "$QUEUE_FILE" 2>/dev/null | while IFS='|' read -r priority parent subissue status worker created; do
            if [ "$status" = "pending" ] || [ "$status" = "working" ]; then
                printf "%-8s | #%-5s | #%-7s | %-7s | %s\n" "$priority" "$parent" "$subissue" "$status" "${worker:-none}"
            fi
        done
    fi
}

# Show items by parent issue
queue_by_parent() {
    local parent_issue="$1"
    
    if [ -z "$parent_issue" ]; then
        echo "Usage: queue by-parent PARENT_ISSUE"
        return 1
    fi
    
    echo "üìã Subissues for parent #$parent_issue"
    echo "================================"
    
    local total=0
    local completed=0
    
    # Check active queue
    grep "|$parent_issue|" "$QUEUE_FILE" 2>/dev/null | while IFS='|' read -r priority parent subissue status worker created; do
        echo "#$subissue - $status"
        ((total++))
    done
    
    # Check completed
    grep "|$parent_issue|" "$COMPLETED_FILE" 2>/dev/null | while IFS='|' read -r priority parent subissue status worker created completed_at; do
        echo "#$subissue - completed"
        ((total++))
        ((completed++))
    done
    
    # Check failed
    grep "|$parent_issue|" "$FAILED_FILE" 2>/dev/null | while IFS='|' read -r priority parent subissue status worker created failed_at; do
        echo "#$subissue - failed"
        ((total++))
    done
    
    echo ""
    echo "Progress: $completed/$total completed"
}

# Retry failed items
queue_retry() {
    local subissue_id="$1"
    
    if [ "$subissue_id" = "all" ]; then
        echo "üîÑ Retrying all failed items..."
        acquire_lock || return 1
        
        # Move all failed items back to queue as pending
        while IFS='|' read -r priority parent sid status worker created failed_at; do
            echo "${priority}|${parent}|${sid}|pending||${created}" >> "$QUEUE_FILE"
            echo "‚Ü©Ô∏è  Moved #$sid back to queue"
        done < "$FAILED_FILE"
        
        > "$FAILED_FILE"  # Clear failed file
        release_lock
        
        echo "‚úÖ All failed items returned to queue"
    elif [ -n "$subissue_id" ]; then
        echo "üîÑ Retrying subissue #$subissue_id..."
        acquire_lock || return 1
        
        # Find and move specific failed item
        local temp_file=$(mktemp)
        local found=false
        
        while IFS='|' read -r priority parent sid status worker created failed_at; do
            if [ "$sid" = "$subissue_id" ]; then
                echo "${priority}|${parent}|${sid}|pending||${created}" >> "$QUEUE_FILE"
                echo "‚Ü©Ô∏è  Moved #$sid back to queue"
                found=true
            else
                echo "${priority}|${parent}|${sid}|${status}|${worker}|${created}|${failed_at}" >> "$temp_file"
            fi
        done < "$FAILED_FILE"
        
        mv "$temp_file" "$FAILED_FILE"
        release_lock
        
        if [ "$found" = true ]; then
            echo "‚úÖ Subissue #$subissue_id returned to queue"
        else
            echo "‚ùå Subissue #$subissue_id not found in failed items"
        fi
    else
        echo "Usage: queue retry SUBISSUE_ID|all"
        return 1
    fi
}

# Clear completed items older than N days
queue_clean() {
    local days="${1:-7}"
    
    echo "üßπ Cleaning completed items older than $days days..."
    
    acquire_lock || return 1
    
    local cutoff_date=$(date -u -d "$days days ago" +%Y-%m-%dT%H:%M:%SZ)
    local temp_file=$(mktemp)
    local cleaned=0
    
    while IFS='|' read -r priority parent sid status worker created completed_at; do
        if [[ "$completed_at" > "$cutoff_date" ]]; then
            echo "${priority}|${parent}|${sid}|${status}|${worker}|${created}|${completed_at}" >> "$temp_file"
        else
            ((cleaned++))
        fi
    done < "$COMPLETED_FILE"
    
    mv "$temp_file" "$COMPLETED_FILE"
    release_lock
    
    echo "‚úÖ Cleaned $cleaned old completed items"
}

# Main command handling
case "${1:-status}" in
    add)
        shift
        queue_add "$@"
        ;;
    
    next)
        shift
        queue_next "$@"
        ;;
    
    update)
        shift
        queue_update "$@"
        ;;
    
    status)
        queue_status
        ;;
    
    by-parent)
        shift
        queue_by_parent "$@"
        ;;
    
    retry)
        shift
        queue_retry "$@"
        ;;
    
    clean)
        shift
        queue_clean "$@"
        ;;
    
    *)
        echo "Usage: queue <command> [args]"
        echo ""
        echo "Commands:"
        echo "  add PRIORITY PARENT SUBISSUE    - Add item to queue"
        echo "  next [WORKER_ID]                - Get next item from queue"
        echo "  update SUBISSUE STATUS [WORKER] - Update item status"
        echo "  status                          - Show queue status"
        echo "  by-parent PARENT_ISSUE          - Show items for parent issue"
        echo "  retry SUBISSUE_ID|all           - Retry failed items"
        echo "  clean [DAYS]                    - Clean old completed items"
        echo ""
        echo "Status values: pending, working, completed, failed"
        echo "Priority: 1 (highest) to 4 (lowest)"
        ;;
esac