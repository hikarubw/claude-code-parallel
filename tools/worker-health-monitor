#!/bin/bash
# Worker Health Monitor - Track and report worker health status
# Part of the enhanced hybrid architecture with error recovery

set -e

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Health monitoring configuration
HEALTH_DIR="$HOME/.claude/workers/health"
METRICS_FILE="$HEALTH_DIR/metrics.json"
HEALTH_LOG="$HEALTH_DIR/health.log"
ALERT_LOG="$HEALTH_DIR/alerts.log"

# Health check intervals (seconds)
HEARTBEAT_INTERVAL=5
HEALTH_CHECK_INTERVAL=10
DEAD_WORKER_THRESHOLD=30  # Worker considered dead after this many seconds
SLOW_TASK_THRESHOLD=900   # 15 minutes - task considered slow

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m'

# Ensure health directory exists
mkdir -p "$HEALTH_DIR"

# Initialize metrics file if it doesn't exist
if [ ! -f "$METRICS_FILE" ]; then
    echo '{"workers": {}, "stats": {"total_tasks": 0, "successful_tasks": 0, "failed_tasks": 0, "restarts": 0}}' > "$METRICS_FILE"
fi

# Log function
log_event() {
    local level=$1
    local message=$2
    local timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    echo "[$timestamp] [$level] $message" >> "$HEALTH_LOG"
    
    if [ "$level" = "ERROR" ] || [ "$level" = "ALERT" ]; then
        echo "[$timestamp] $message" >> "$ALERT_LOG"
    fi
}

# Update worker heartbeat
update_heartbeat() {
    local worker_id=$1
    local status="${2:-alive}"
    local current_task="${3:-none}"
    local timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    
    # Update metrics using jq
    jq --arg wid "$worker_id" \
       --arg status "$status" \
       --arg task "$current_task" \
       --arg ts "$timestamp" \
       '.workers[$wid] = {
           "last_heartbeat": $ts,
           "status": $status,
           "current_task": $task,
           "started_at": (.workers[$wid].started_at // $ts),
           "tasks_completed": (.workers[$wid].tasks_completed // 0),
           "tasks_failed": (.workers[$wid].tasks_failed // 0),
           "restarts": (.workers[$wid].restarts // 0)
       }' "$METRICS_FILE" > "$METRICS_FILE.tmp" && mv "$METRICS_FILE.tmp" "$METRICS_FILE"
}

# Check worker health
check_worker_health() {
    local worker_id=$1
    local current_time=$(date +%s)
    
    # Get worker info
    local worker_info=$(jq -r --arg wid "$worker_id" '.workers[$wid] // empty' "$METRICS_FILE")
    
    if [ -z "$worker_info" ]; then
        echo "unknown"
        return
    fi
    
    local last_heartbeat=$(echo "$worker_info" | jq -r '.last_heartbeat')
    local status=$(echo "$worker_info" | jq -r '.status')
    local current_task=$(echo "$worker_info" | jq -r '.current_task')
    
    # Convert heartbeat to epoch
    local heartbeat_epoch=$(date -d "$last_heartbeat" +%s 2>/dev/null || echo 0)
    local time_since_heartbeat=$((current_time - heartbeat_epoch))
    
    if [ $time_since_heartbeat -gt $DEAD_WORKER_THRESHOLD ]; then
        echo "dead"
        log_event "ERROR" "Worker $worker_id is dead (no heartbeat for ${time_since_heartbeat}s)"
    elif [ $time_since_heartbeat -gt $((DEAD_WORKER_THRESHOLD / 2)) ]; then
        echo "unresponsive"
        log_event "WARN" "Worker $worker_id is unresponsive (no heartbeat for ${time_since_heartbeat}s)"
    elif [ "$current_task" != "none" ]; then
        # Check if task is taking too long
        local task_duration=$time_since_heartbeat
        if [ $task_duration -gt $SLOW_TASK_THRESHOLD ]; then
            echo "slow"
            log_event "WARN" "Worker $worker_id task is slow (running for ${task_duration}s)"
        else
            echo "healthy"
        fi
    else
        echo "healthy"
    fi
}

# Get worker metrics
get_worker_metrics() {
    local worker_id=$1
    jq -r --arg wid "$worker_id" '
        .workers[$wid] // {
            "status": "not_found",
            "tasks_completed": 0,
            "tasks_failed": 0,
            "restarts": 0
        }' "$METRICS_FILE"
}

# Update task completion
update_task_completion() {
    local worker_id=$1
    local success=$2  # true/false
    
    if [ "$success" = "true" ]; then
        jq --arg wid "$worker_id" '
            .workers[$wid].tasks_completed += 1 |
            .workers[$wid].current_task = "none" |
            .stats.successful_tasks += 1 |
            .stats.total_tasks += 1
        ' "$METRICS_FILE" > "$METRICS_FILE.tmp" && mv "$METRICS_FILE.tmp" "$METRICS_FILE"
        
        log_event "INFO" "Worker $worker_id completed task successfully"
    else
        jq --arg wid "$worker_id" '
            .workers[$wid].tasks_failed += 1 |
            .workers[$wid].current_task = "none" |
            .stats.failed_tasks += 1 |
            .stats.total_tasks += 1
        ' "$METRICS_FILE" > "$METRICS_FILE.tmp" && mv "$METRICS_FILE.tmp" "$METRICS_FILE"
        
        log_event "WARN" "Worker $worker_id task failed"
    fi
}

# Record worker restart
record_restart() {
    local worker_id=$1
    jq --arg wid "$worker_id" '
        .workers[$wid].restarts += 1 |
        .stats.restarts += 1
    ' "$METRICS_FILE" > "$METRICS_FILE.tmp" && mv "$METRICS_FILE.tmp" "$METRICS_FILE"
    
    log_event "INFO" "Worker $worker_id restarted"
}

# Monitor all workers
monitor_all_workers() {
    echo -e "${BLUE}Starting worker health monitoring...${NC}"
    
    while true; do
        # Check each worker in tmux session
        if tmux has-session -t claude-workers 2>/dev/null; then
            tmux list-panes -t claude-workers -F "#{pane_index}" 2>/dev/null | while read pane_index; do
                worker_id=$((pane_index + 1))
                
                # Check if pane is running a worker
                local pane_cmd=$(tmux list-panes -t claude-workers -F "#{pane_index}:#{pane_current_command}" | grep "^$pane_index:" | cut -d: -f2)
                
                if [[ "$pane_cmd" == *"hybrid-worker"* ]] || [[ "$pane_cmd" == *"bash"* ]]; then
                    # Get worker status from Pueue
                    local pueue_status=$(pueue status --json 2>/dev/null | jq -r --arg wid "$worker_id" '
                        .tasks | to_entries[] |
                        select(.value.label | test("worker-\\($wid)-")) |
                        .value.status
                    ' | head -1)
                    
                    # Check health
                    local health=$(check_worker_health $worker_id)
                    
                    if [ "$health" = "dead" ] || [ "$health" = "unresponsive" ]; then
                        log_event "ALERT" "Worker $worker_id is $health - needs restart"
                    fi
                fi
            done
        fi
        
        sleep $HEALTH_CHECK_INTERVAL
    done
}

# Display health dashboard
health_dashboard() {
    while true; do
        clear
        echo -e "${BLUE}=== Worker Health Dashboard ===${NC}"
        echo -e "Last Update: $(date)"
        echo ""
        
        # Overall stats
        local stats=$(jq -r '.stats' "$METRICS_FILE")
        echo -e "${GREEN}Overall Statistics:${NC}"
        echo "Total Tasks:      $(echo "$stats" | jq -r '.total_tasks')"
        echo "Successful:       $(echo "$stats" | jq -r '.successful_tasks')"
        echo "Failed:           $(echo "$stats" | jq -r '.failed_tasks')"
        echo "Total Restarts:   $(echo "$stats" | jq -r '.restarts')"
        echo ""
        
        # Worker status
        echo -e "${GREEN}Worker Status:${NC}"
        echo "ID | Status      | Current Task    | Completed | Failed | Restarts | Last Seen"
        echo "---|-------------|-----------------|-----------|--------|----------|----------"
        
        jq -r '.workers | to_entries[] | 
            "\(.key)|\(.value.status)|\(.value.current_task)|\(.value.tasks_completed)|\(.value.tasks_failed)|\(.value.restarts)|\(.value.last_heartbeat)"' "$METRICS_FILE" | \
        while IFS='|' read -r id status task completed failed restarts heartbeat; do
            # Calculate time since heartbeat
            local current_time=$(date +%s)
            local heartbeat_epoch=$(date -d "$heartbeat" +%s 2>/dev/null || echo 0)
            local time_ago=$((current_time - heartbeat_epoch))
            
            # Color code status
            case "$status" in
                "alive"|"healthy")
                    status_color=$GREEN
                    ;;
                "slow"|"unresponsive")
                    status_color=$YELLOW
                    ;;
                "dead"|"failed")
                    status_color=$RED
                    ;;
                *)
                    status_color=$NC
                    ;;
            esac
            
            printf "%-2s | ${status_color}%-11s${NC} | %-15s | %-9s | %-6s | %-8s | %ds ago\n" \
                "$id" "$status" "${task:0:15}" "$completed" "$failed" "$restarts" "$time_ago"
        done
        
        echo ""
        echo -e "${YELLOW}Recent Alerts:${NC}"
        tail -5 "$ALERT_LOG" 2>/dev/null || echo "No recent alerts"
        
        sleep 2
    done
}

# Get health report
health_report() {
    local format="${1:-text}"
    
    if [ "$format" = "json" ]; then
        cat "$METRICS_FILE"
    else
        echo "Worker Health Report"
        echo "==================="
        echo ""
        
        # Overall health
        local total_workers=$(jq -r '.workers | length' "$METRICS_FILE")
        local healthy_workers=$(jq -r '.workers | to_entries[] | select(.value.status == "alive" or .value.status == "healthy") | .key' "$METRICS_FILE" | wc -l)
        local success_rate=0
        
        local total_tasks=$(jq -r '.stats.total_tasks' "$METRICS_FILE")
        if [ $total_tasks -gt 0 ]; then
            local successful_tasks=$(jq -r '.stats.successful_tasks' "$METRICS_FILE")
            success_rate=$(awk "BEGIN {printf \"%.1f\", ($successful_tasks / $total_tasks) * 100}")
        fi
        
        echo "Overall Health: $healthy_workers/$total_workers workers healthy"
        echo "Success Rate: ${success_rate}%"
        echo ""
        
        # Per-worker report
        echo "Worker Details:"
        jq -r '.workers | to_entries[] | 
            "Worker \(.key): \(.value.status) - \(.value.tasks_completed) completed, \(.value.tasks_failed) failed, \(.value.restarts) restarts"' "$METRICS_FILE"
    fi
}

# Reset metrics
reset_metrics() {
    echo '{"workers": {}, "stats": {"total_tasks": 0, "successful_tasks": 0, "failed_tasks": 0, "restarts": 0}}' > "$METRICS_FILE"
    > "$HEALTH_LOG"
    > "$ALERT_LOG"
    echo "Health metrics reset"
}

# Main command handling
case "${1:-help}" in
    heartbeat)
        update_heartbeat "$2" "${3:-alive}" "${4:-none}"
        ;;
    
    check)
        check_worker_health "$2"
        ;;
    
    metrics)
        get_worker_metrics "$2"
        ;;
    
    complete)
        update_task_completion "$2" "$3"
        ;;
    
    restart)
        record_restart "$2"
        ;;
    
    monitor)
        monitor_all_workers
        ;;
    
    dashboard)
        health_dashboard
        ;;
    
    report)
        health_report "${2:-text}"
        ;;
    
    reset)
        reset_metrics
        ;;
    
    *)
        echo "Usage: worker-health-monitor <command> [args]"
        echo ""
        echo "Commands:"
        echo "  heartbeat ID [STATUS] [TASK]  - Update worker heartbeat"
        echo "  check ID                      - Check worker health"
        echo "  metrics ID                    - Get worker metrics"
        echo "  complete ID true|false        - Record task completion"
        echo "  restart ID                    - Record worker restart"
        echo "  monitor                       - Monitor all workers continuously"
        echo "  dashboard                     - Show live health dashboard"
        echo "  report [json|text]           - Generate health report"
        echo "  reset                        - Reset all metrics"
        echo ""
        echo "This tool tracks worker health and provides metrics for the hybrid architecture."
        ;;
esac