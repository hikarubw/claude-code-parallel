#!/bin/bash
# Worker Manager - Monitors and manages all workers with automatic recovery
# Ensures workers stay healthy and restarts dead workers

set -e

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Configuration
SESSION="claude-workers"
MONITOR_SESSION="claude-monitor"
DEFAULT_WORKERS=4
CHECK_INTERVAL=10
RESTART_DELAY=5
MAX_RESTART_ATTEMPTS=5
MANAGER_LOG="$HOME/.claude/workers/manager.log"
STATE_DIR="$HOME/.claude/workers/state"

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Ensure directories exist
mkdir -p "$(dirname "$MANAGER_LOG")"
mkdir -p "$STATE_DIR"

# Logging function
log() {
    local level=$1
    local message=$2
    local timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    echo "[$timestamp] [$level] $message" | tee -a "$MANAGER_LOG"
}

# Check if tmux session exists
check_session() {
    tmux has-session -t "$SESSION" 2>/dev/null
}

# Get number of active workers
get_active_workers() {
    if check_session; then
        tmux list-panes -t "$SESSION" -F "#{pane_index}" 2>/dev/null | wc -l
    else
        echo 0
    fi
}

# Check worker status
check_worker_status() {
    local worker_id=$1
    local pane_index=$((worker_id - 1))
    
    # Check if pane exists
    if ! tmux list-panes -t "$SESSION" -F "#{pane_index}" 2>/dev/null | grep -q "^$pane_index$"; then
        echo "missing"
        return
    fi
    
    # Check pane process
    local pane_cmd=$(tmux list-panes -t "$SESSION:0.$pane_index" -F "#{pane_current_command}" 2>/dev/null || echo "")
    
    if [[ "$pane_cmd" == *"hybrid-worker"* ]]; then
        # Check health from monitor
        local health=$("$SCRIPT_DIR/worker-health-monitor" check "$worker_id" 2>/dev/null || echo "unknown")
        echo "$health"
    elif [[ "$pane_cmd" == "bash" ]] || [[ "$pane_cmd" == "zsh" ]]; then
        echo "idle"
    else
        echo "unknown"
    fi
}

# Start a single worker
start_worker() {
    local worker_id=$1
    local use_enhanced=${2:-true}
    
    log "INFO" "Starting worker $worker_id"
    
    if ! check_session; then
        log "ERROR" "Worker session not found"
        return 1
    fi
    
    local pane_index=$((worker_id - 1))
    
    # Select the worker script
    local worker_script="hybrid-worker"
    if [ "$use_enhanced" = "true" ] && [ -x "$SCRIPT_DIR/hybrid-worker-enhanced" ]; then
        worker_script="hybrid-worker-enhanced"
        log "INFO" "Using enhanced worker for worker $worker_id"
    fi
    
    # Send command to start worker
    tmux send-keys -t "$SESSION:0.$pane_index" C-c 2>/dev/null || true
    sleep 0.5
    tmux send-keys -t "$SESSION:0.$pane_index" "clear && $SCRIPT_DIR/$worker_script $worker_id" Enter
    
    # Update health monitor
    "$SCRIPT_DIR/worker-health-monitor" heartbeat "$worker_id" "starting" || true
    
    log "INFO" "Worker $worker_id started successfully"
}

# Restart a dead worker
restart_worker() {
    local worker_id=$1
    local attempt=${2:-1}
    
    log "WARN" "Restarting worker $worker_id (attempt $attempt)"
    
    # Record restart in health monitor
    "$SCRIPT_DIR/worker-health-monitor" restart "$worker_id" || true
    
    # Kill any stuck processes in the pane
    local pane_index=$((worker_id - 1))
    tmux send-keys -t "$SESSION:0.$pane_index" C-c 2>/dev/null || true
    sleep 1
    tmux send-keys -t "$SESSION:0.$pane_index" C-d 2>/dev/null || true
    sleep 1
    
    # Start the worker
    start_worker "$worker_id" true
    
    # Wait and verify
    sleep $RESTART_DELAY
    
    local status=$(check_worker_status "$worker_id")
    if [[ "$status" == "healthy" ]] || [[ "$status" == "idle" ]]; then
        log "INFO" "Worker $worker_id restarted successfully"
        return 0
    else
        log "ERROR" "Worker $worker_id failed to restart properly (status: $status)"
        return 1
    fi
}

# Monitor and maintain workers
monitor_workers() {
    log "INFO" "Starting worker monitoring"
    
    local restart_counts=()
    local monitoring=true
    
    # Trap for clean shutdown
    trap 'monitoring=false; log "INFO" "Worker monitoring stopped"' EXIT INT TERM
    
    while [ "$monitoring" = "true" ]; do
        # Check if session exists
        if ! check_session; then
            log "ERROR" "Worker session lost - cannot monitor"
            sleep $CHECK_INTERVAL
            continue
        fi
        
        # Get configured number of workers
        local num_workers=$(get_active_workers)
        
        # Check each worker
        for ((i=1; i<=num_workers; i++)); do
            local status=$(check_worker_status $i)
            
            case "$status" in
                "dead"|"unresponsive")
                    log "ALERT" "Worker $i is $status"
                    
                    # Check restart count
                    local restart_count=${restart_counts[$i]:-0}
                    
                    if [ $restart_count -lt $MAX_RESTART_ATTEMPTS ]; then
                        if restart_worker $i $((restart_count + 1)); then
                            restart_counts[$i]=$((restart_count + 1))
                        else
                            log "ERROR" "Failed to restart worker $i"
                        fi
                    else
                        log "ERROR" "Worker $i exceeded max restart attempts ($MAX_RESTART_ATTEMPTS)"
                    fi
                    ;;
                
                "healthy"|"idle"|"working")
                    # Reset restart count on healthy status
                    restart_counts[$i]=0
                    ;;
                
                "slow")
                    log "WARN" "Worker $i is processing slowly"
                    ;;
                
                "missing")
                    log "ERROR" "Worker $i pane is missing"
                    ;;
            esac
        done
        
        sleep $CHECK_INTERVAL
    done
}

# Start monitoring in background
start_monitoring() {
    log "INFO" "Starting worker manager daemon"
    
    # Check if already running
    if tmux has-session -t "$MONITOR_SESSION" 2>/dev/null; then
        echo -e "${YELLOW}Worker manager already running${NC}"
        return
    fi
    
    # Create monitoring session
    tmux new-session -d -s "$MONITOR_SESSION" -n "manager"
    tmux send-keys -t "$MONITOR_SESSION:0" "$SCRIPT_DIR/worker-manager monitor" Enter
    
    echo -e "${GREEN}Worker manager started in background${NC}"
    echo "View logs: tail -f $MANAGER_LOG"
    echo "Attach to monitor: tmux attach -t $MONITOR_SESSION"
}

# Stop monitoring
stop_monitoring() {
    log "INFO" "Stopping worker manager"
    
    if tmux has-session -t "$MONITOR_SESSION" 2>/dev/null; then
        tmux kill-session -t "$MONITOR_SESSION"
        echo -e "${GREEN}Worker manager stopped${NC}"
    else
        echo -e "${YELLOW}Worker manager not running${NC}"
    fi
}

# Show manager status
show_status() {
    echo -e "${BLUE}=== Worker Manager Status ===${NC}"
    echo ""
    
    # Check if monitoring
    if tmux has-session -t "$MONITOR_SESSION" 2>/dev/null; then
        echo -e "Manager: ${GREEN}Running${NC}"
    else
        echo -e "Manager: ${RED}Not running${NC}"
    fi
    
    echo ""
    
    # Show worker status
    if check_session; then
        local num_workers=$(get_active_workers)
        echo "Workers: $num_workers active"
        echo ""
        echo "ID | Status       | Health Report"
        echo "---|--------------|------------------"
        
        for ((i=1; i<=num_workers; i++)); do
            local status=$(check_worker_status $i)
            local metrics=$("$SCRIPT_DIR/worker-health-monitor" metrics $i 2>/dev/null | jq -r '. | "Tasks: \(.tasks_completed // 0) done, \(.tasks_failed // 0) failed"' 2>/dev/null || echo "No metrics")
            
            # Color code status
            case "$status" in
                "healthy"|"working")
                    status_display="${GREEN}$status${NC}"
                    ;;
                "dead"|"unresponsive"|"missing")
                    status_display="${RED}$status${NC}"
                    ;;
                *)
                    status_display="${YELLOW}$status${NC}"
                    ;;
            esac
            
            printf "%-2s | %-20b | %s\n" "$i" "$status_display" "$metrics"
        done
    else
        echo -e "${RED}No worker session found${NC}"
    fi
    
    echo ""
    echo "Recent manager logs:"
    tail -5 "$MANAGER_LOG" 2>/dev/null || echo "No logs available"
}

# Restart all workers
restart_all_workers() {
    log "INFO" "Restarting all workers"
    
    if ! check_session; then
        echo -e "${RED}No worker session found${NC}"
        return 1
    fi
    
    local num_workers=$(get_active_workers)
    
    for ((i=1; i<=num_workers; i++)); do
        echo -e "${YELLOW}Restarting worker $i...${NC}"
        start_worker $i true
        sleep 1
    done
    
    echo -e "${GREEN}All workers restarted${NC}"
}

# Scale workers up or down
scale_workers() {
    local target_count=$1
    
    if ! check_session; then
        echo -e "${RED}No worker session found${NC}"
        return 1
    fi
    
    local current_count=$(get_active_workers)
    
    if [ $target_count -eq $current_count ]; then
        echo "Already have $target_count workers"
        return
    fi
    
    if [ $target_count -gt $current_count ]; then
        # Scale up
        local add_count=$((target_count - current_count))
        echo -e "${GREEN}Scaling up: adding $add_count workers${NC}"
        
        for ((i=1; i<=add_count; i++)); do
            tmux split-window -t "$SESSION:0" -v
            tmux select-layout -t "$SESSION:0" tiled
        done
        
        sleep 1
        
        # Start new workers
        for ((i=$((current_count + 1)); i<=target_count; i++)); do
            start_worker $i true
        done
    else
        # Scale down
        echo -e "${YELLOW}Scaling down to $target_count workers${NC}"
        
        for ((i=$target_count; i<$current_count; i++)); do
            local pane_index=$i
            tmux kill-pane -t "$SESSION:0.$pane_index"
        done
        
        tmux select-layout -t "$SESSION:0" tiled
    fi
    
    log "INFO" "Scaled workers from $current_count to $target_count"
}

# Main command handling
case "${1:-help}" in
    start)
        start_monitoring
        ;;
    
    stop)
        stop_monitoring
        ;;
    
    monitor)
        monitor_workers
        ;;
    
    status)
        show_status
        ;;
    
    restart)
        if [ -n "$2" ]; then
            restart_worker "$2"
        else
            restart_all_workers
        fi
        ;;
    
    scale)
        if [ -n "$2" ]; then
            scale_workers "$2"
        else
            echo "Usage: worker-manager scale NUMBER"
        fi
        ;;
    
    health)
        "$SCRIPT_DIR/worker-health-monitor" dashboard
        ;;
    
    logs)
        tail -f "$MANAGER_LOG"
        ;;
    
    *)
        echo "Usage: worker-manager <command> [args]"
        echo ""
        echo "Commands:"
        echo "  start              - Start manager daemon"
        echo "  stop               - Stop manager daemon"
        echo "  status             - Show current status"
        echo "  restart [ID]       - Restart specific or all workers"
        echo "  scale NUMBER       - Scale to NUMBER workers"
        echo "  health             - Show health dashboard"
        echo "  logs               - Follow manager logs"
        echo "  monitor            - Run monitoring loop (internal)"
        echo ""
        echo "The worker manager ensures workers stay healthy and automatically"
        echo "restarts failed workers. It runs as a background daemon."
        ;;
esac