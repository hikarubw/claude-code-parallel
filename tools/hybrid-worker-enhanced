#!/bin/bash
# Enhanced Hybrid Worker - With error recovery and health monitoring
# Revolutionary Pueue + Tmux architecture with resilience

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

WORKER_ID=${1:-1}
WORKER_NAME="worker-$WORKER_ID"
SESSION="claude-workers"
PANE_ID="$SESSION:0.$WORKER_ID"

# Error recovery configuration
MAX_RETRIES=3
RETRY_DELAY=5
ERROR_LOG="$HOME/.claude/workers/errors/worker-$WORKER_ID.log"
STATE_FILE="$HOME/.claude/workers/state/worker-$WORKER_ID.state"

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m'

# Ensure directories exist
mkdir -p "$HOME/.claude/workers/errors"
mkdir -p "$HOME/.claude/workers/state"

# Trap for clean shutdown
trap cleanup EXIT INT TERM

# Cleanup function
cleanup() {
    echo -e "${YELLOW}Worker $WORKER_ID shutting down...${NC}"
    "$SCRIPT_DIR/worker-health-monitor" heartbeat "$WORKER_ID" "stopped"
    save_state "stopped"
    exit 0
}

# Log error with timestamp
log_error() {
    local message=$1
    local timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    echo "[$timestamp] $message" >> "$ERROR_LOG"
    echo -e "${RED}Error: $message${NC}"
}

# Save worker state
save_state() {
    local status=$1
    local current_task="${2:-none}"
    local retry_count="${3:-0}"
    
    cat > "$STATE_FILE" << EOF
{
    "worker_id": "$WORKER_ID",
    "status": "$status",
    "current_task": "$current_task",
    "retry_count": $retry_count,
    "last_update": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF
}

# Load worker state
load_state() {
    if [ -f "$STATE_FILE" ]; then
        cat "$STATE_FILE"
    else
        echo '{"status": "new", "current_task": "none", "retry_count": 0}'
    fi
}

# Check Pueue daemon with retry
ensure_pueue_daemon() {
    local retries=0
    while [ $retries -lt 3 ]; do
        if pueue status &>/dev/null; then
            return 0
        fi
        
        echo -e "${YELLOW}Pueue daemon not running, attempting to start...${NC}"
        pueued -d &>/dev/null || true
        sleep 2
        ((retries++))
    done
    
    log_error "Failed to start Pueue daemon after $retries attempts"
    return 1
}

# Validate git repository
validate_git_repo() {
    if ! git rev-parse --show-toplevel &>/dev/null; then
        log_error "Not in a git repository"
        return 1
    fi
    return 0
}

# Safe worktree creation with cleanup
create_worktree_safe() {
    local worktree_path=$1
    local branch_name=$2
    local max_attempts=3
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        # Clean up any existing worktree
        if [ -d "$worktree_path" ]; then
            echo "Cleaning up existing worktree..."
            git worktree remove "$worktree_path" --force 2>/dev/null || true
            rm -rf "$worktree_path" 2>/dev/null || true
        fi
        
        # Try to create worktree
        if git worktree add "$worktree_path" -b "$branch_name" 2>/dev/null; then
            return 0
        fi
        
        # If branch exists, try with a unique suffix
        branch_name="${branch_name}-${attempt}"
        echo "Retrying with branch name: $branch_name"
        ((attempt++))
    done
    
    log_error "Failed to create worktree after $max_attempts attempts"
    return 1
}

# Execute task with timeout and monitoring
execute_task_safe() {
    local subissue_id=$1
    local parent_issue=$2
    local timeout=${3:-3600}  # Default 1 hour timeout
    
    # Start a background timer
    (
        sleep $timeout
        echo -e "${RED}Task timeout reached for subissue #$subissue_id${NC}"
        # The parent process will handle the timeout
    ) &
    local timer_pid=$!
    
    # Run Claude with work instruction
    claude "/work-on subissue #$subissue_id of parent issue #$parent_issue && create a pull request when done"
    local claude_exit_code=$?
    
    # Kill the timer
    kill $timer_pid 2>/dev/null || true
    
    return $claude_exit_code
}

# Recovery from failure
recover_from_failure() {
    local subissue_id=$1
    local error_type=$2
    local retry_count=$3
    
    case "$error_type" in
        "worktree_error")
            echo -e "${YELLOW}Attempting to recover from worktree error...${NC}"
            # Clean all worktrees for this worker
            git worktree list | grep "worker-$WORKER_ID" | cut -d' ' -f1 | xargs -r git worktree remove --force
            ;;
        
        "git_error")
            echo -e "${YELLOW}Attempting to recover from git error...${NC}"
            # Reset to clean state
            git reset --hard HEAD 2>/dev/null || true
            git clean -fd 2>/dev/null || true
            ;;
        
        "claude_error")
            echo -e "${YELLOW}Claude execution failed, will retry...${NC}"
            # Just retry, might be transient
            ;;
        
        *)
            echo -e "${YELLOW}Unknown error, attempting general recovery...${NC}"
            ;;
    esac
    
    # Update health monitor
    "$SCRIPT_DIR/worker-health-monitor" heartbeat "$WORKER_ID" "recovering" "subissue-$subissue_id"
    
    # Wait before retry
    sleep $RETRY_DELAY
}

# Main worker loop with error handling
main_loop() {
    echo -e "${GREEN}Enhanced Hybrid Worker $WORKER_ID starting...${NC}"
    echo "Running in tmux pane: $PANE_ID"
    echo "Error logs: $ERROR_LOG"
    
    # Initialize health monitoring
    "$SCRIPT_DIR/worker-health-monitor" heartbeat "$WORKER_ID" "starting"
    
    # Load previous state
    local previous_state=$(load_state)
    local last_task=$(echo "$previous_state" | jq -r '.current_task // "none"')
    
    if [ "$last_task" != "none" ] && [ "$last_task" != "null" ]; then
        echo -e "${YELLOW}Resuming from previous task: $last_task${NC}"
    fi
    
    while true; do
        # Update heartbeat
        "$SCRIPT_DIR/worker-health-monitor" heartbeat "$WORKER_ID" "idle"
        
        # Ensure Pueue daemon is running
        if ! ensure_pueue_daemon; then
            sleep 10
            continue
        fi
        
        # Get next queued task from Pueue
        NEXT_TASK=$(pueue status --json 2>/dev/null | jq -r --arg group "subissues" '
            .tasks | to_entries[] |
            select(.value.status == "Queued" and 
                   (.value.group // "default") == $group and
                   (.value.label | startswith("subissue-"))) |
            .value | {id, label, command} | @json
        ' | head -1)
        
        if [[ -z "$NEXT_TASK" || "$NEXT_TASK" == "null" ]]; then
            echo -ne "\r[$(date +%H:%M:%S)] No subissues in queue. Waiting..."
            sleep 2
            continue
        fi
        
        # Parse task details
        TASK_ID=$(echo "$NEXT_TASK" | jq -r '.id')
        SUBISSUE_LABEL=$(echo "$NEXT_TASK" | jq -r '.label')
        SUBISSUE_ID=$(echo "$SUBISSUE_LABEL" | cut -d- -f2)
        
        echo -e "\n${YELLOW}[$(date +%H:%M:%S)] Found task: $SUBISSUE_LABEL (Pueue ID: $TASK_ID)${NC}"
        
        # Start the task in Pueue
        pueue start $TASK_ID
        
        # Update health monitor
        "$SCRIPT_DIR/worker-health-monitor" heartbeat "$WORKER_ID" "working" "$SUBISSUE_LABEL"
        
        # Get subissue details from queue
        QUEUE_ITEM=$("$SCRIPT_DIR/queue" get "subissue-$SUBISSUE_ID" 2>/dev/null)
        if [[ -z "$QUEUE_ITEM" ]]; then
            log_error "Subissue $SUBISSUE_ID not found in queue"
            pueue kill $TASK_ID
            "$SCRIPT_DIR/worker-health-monitor" complete "$WORKER_ID" "false"
            continue
        fi
        
        # Parse queue item
        PARENT_ISSUE=$(echo "$QUEUE_ITEM" | cut -d'|' -f2)
        
        echo -e "${GREEN}Processing subissue #$SUBISSUE_ID (parent: #$PARENT_ISSUE)${NC}"
        save_state "working" "subissue-$SUBISSUE_ID" 0
        
        # Process with retry logic
        local retry_count=0
        local task_success=false
        
        while [ $retry_count -lt $MAX_RETRIES ] && [ "$task_success" = "false" ]; do
            if [ $retry_count -gt 0 ]; then
                echo -e "${YELLOW}Retry attempt $retry_count/$MAX_RETRIES${NC}"
                save_state "retrying" "subissue-$SUBISSUE_ID" $retry_count
            fi
            
            # Validate git repository
            if ! validate_git_repo; then
                recover_from_failure "$SUBISSUE_ID" "git_error" $retry_count
                ((retry_count++))
                continue
            fi
            
            # Create worktree
            WORKTREE_PATH=".worktrees/subissue-$SUBISSUE_ID"
            BRANCH_NAME="subissue/$PARENT_ISSUE-$SUBISSUE_ID"
            
            cd $(git rev-parse --show-toplevel)
            
            if ! create_worktree_safe "$WORKTREE_PATH" "$BRANCH_NAME"; then
                recover_from_failure "$SUBISSUE_ID" "worktree_error" $retry_count
                ((retry_count++))
                continue
            fi
            
            # Move to worktree
            cd "$WORKTREE_PATH"
            
            # Update queue status
            "$SCRIPT_DIR/queue" update "subissue-$SUBISSUE_ID" status working assigned_to "$WORKER_NAME"
            
            echo -e "${GREEN}Starting Claude in visible tmux pane...${NC}"
            
            # Execute task with monitoring
            if execute_task_safe "$SUBISSUE_ID" "$PARENT_ISSUE"; then
                # Check if PR was created
                if gh pr list --head "$BRANCH_NAME" 2>/dev/null | grep -q "$BRANCH_NAME"; then
                    echo -e "${GREEN}PR created successfully!${NC}"
                    "$SCRIPT_DIR/queue" update "subissue-$SUBISSUE_ID" status completed
                    pueue success $TASK_ID
                    "$SCRIPT_DIR/worker-health-monitor" complete "$WORKER_ID" "true"
                    task_success=true
                else
                    echo -e "${YELLOW}No PR found, task may need manual review${NC}"
                    "$SCRIPT_DIR/queue" update "subissue-$SUBISSUE_ID" status review
                    pueue kill $TASK_ID
                    "$SCRIPT_DIR/worker-health-monitor" complete "$WORKER_ID" "false"
                    task_success=true  # Don't retry PR creation failures
                fi
            else
                log_error "Claude execution failed for subissue #$SUBISSUE_ID"
                recover_from_failure "$SUBISSUE_ID" "claude_error" $retry_count
                ((retry_count++))
            fi
            
            # Clean up worktree
            cd $(git rev-parse --show-toplevel)
            git worktree remove "$WORKTREE_PATH" --force 2>/dev/null || true
        done
        
        # Handle max retries exceeded
        if [ "$task_success" = "false" ]; then
            log_error "Failed to process subissue #$SUBISSUE_ID after $MAX_RETRIES attempts"
            "$SCRIPT_DIR/queue" update "subissue-$SUBISSUE_ID" status failed
            pueue kill $TASK_ID
            "$SCRIPT_DIR/worker-health-monitor" complete "$WORKER_ID" "false"
        fi
        
        save_state "idle" "none" 0
        echo -e "${BLUE}Looking for next task...${NC}"
    done
}

# Start main loop
main_loop