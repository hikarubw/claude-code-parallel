#!/bin/bash
# Worker Performance Metrics - Analyze and report on worker performance
# Provides insights into task completion rates, timing, and efficiency

set -e

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Data sources
METRICS_FILE="$HOME/.claude/workers/health/metrics.json"
QUEUE_DIR="$HOME/.claude/workers"
COMPLETED_FILE="$QUEUE_DIR/completed.txt"
FAILED_FILE="$QUEUE_DIR/failed.txt"
PUEUE_LOG="$HOME/.local/share/pueue/pueue.log"

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Calculate average task time
calculate_avg_task_time() {
    if [ ! -f "$COMPLETED_FILE" ]; then
        echo "N/A"
        return
    fi
    
    local total_time=0
    local count=0
    
    while IFS='|' read -r priority parent sid status worker created completed_at; do
        if [ -n "$created" ] && [ -n "$completed_at" ]; then
            local start_epoch=$(date -d "$created" +%s 2>/dev/null || echo 0)
            local end_epoch=$(date -d "$completed_at" +%s 2>/dev/null || echo 0)
            
            if [ $start_epoch -gt 0 ] && [ $end_epoch -gt 0 ]; then
                local duration=$((end_epoch - start_epoch))
                total_time=$((total_time + duration))
                ((count++))
            fi
        fi
    done < "$COMPLETED_FILE"
    
    if [ $count -gt 0 ]; then
        local avg=$((total_time / count))
        local minutes=$((avg / 60))
        local seconds=$((avg % 60))
        echo "${minutes}m ${seconds}s"
    else
        echo "N/A"
    fi
}

# Get worker efficiency
get_worker_efficiency() {
    local worker_id=$1
    
    if [ ! -f "$METRICS_FILE" ]; then
        echo "0"
        return
    fi
    
    local completed=$(jq -r --arg wid "$worker_id" '.workers[$wid].tasks_completed // 0' "$METRICS_FILE")
    local failed=$(jq -r --arg wid "$worker_id" '.workers[$wid].tasks_failed // 0' "$METRICS_FILE")
    local total=$((completed + failed))
    
    if [ $total -gt 0 ]; then
        awk "BEGIN {printf \"%.1f\", ($completed / $total) * 100}"
    else
        echo "0"
    fi
}

# Generate performance report
generate_report() {
    echo -e "${CYAN}=== Worker Performance Report ===${NC}"
    echo -e "Generated: $(date)"
    echo ""
    
    # Overall statistics
    if [ -f "$METRICS_FILE" ]; then
        local stats=$(jq -r '.stats' "$METRICS_FILE")
        local total_tasks=$(echo "$stats" | jq -r '.total_tasks // 0')
        local successful=$(echo "$stats" | jq -r '.successful_tasks // 0')
        local failed=$(echo "$stats" | jq -r '.failed_tasks // 0')
        local restarts=$(echo "$stats" | jq -r '.restarts // 0')
        
        echo -e "${BLUE}Overall Performance:${NC}"
        echo "Total Tasks Processed: $total_tasks"
        echo "Successful: $successful ($([ $total_tasks -gt 0 ] && awk "BEGIN {printf \"%.1f%%\", ($successful / $total_tasks) * 100}" || echo "0%"))"
        echo "Failed: $failed ($([ $total_tasks -gt 0 ] && awk "BEGIN {printf \"%.1f%%\", ($failed / $total_tasks) * 100}" || echo "0%"))"
        echo "Worker Restarts: $restarts"
        echo "Average Task Time: $(calculate_avg_task_time)"
        echo ""
    fi
    
    # Queue statistics
    local pending=$(grep -c "|pending||" "$QUEUE_DIR/queue.txt" 2>/dev/null || echo 0)
    local working=$(grep -c "|working|" "$QUEUE_DIR/queue.txt" 2>/dev/null || echo 0)
    
    echo -e "${BLUE}Queue Status:${NC}"
    echo "Pending Tasks: $pending"
    echo "In Progress: $working"
    echo ""
    
    # Per-worker performance
    echo -e "${BLUE}Worker Performance:${NC}"
    echo "ID | Tasks | Success | Failed | Efficiency | Restarts | Status"
    echo "---|-------|---------|--------|------------|----------|-------"
    
    if [ -f "$METRICS_FILE" ]; then
        jq -r '.workers | to_entries[] | .key' "$METRICS_FILE" | sort -n | while read worker_id; do
            local worker_data=$(jq -r --arg wid "$worker_id" '.workers[$wid]' "$METRICS_FILE")
            local completed=$(echo "$worker_data" | jq -r '.tasks_completed // 0')
            local failed=$(echo "$worker_data" | jq -r '.tasks_failed // 0')
            local total=$((completed + failed))
            local restarts=$(echo "$worker_data" | jq -r '.restarts // 0')
            local status=$(echo "$worker_data" | jq -r '.status // "unknown"')
            local efficiency=$(get_worker_efficiency "$worker_id")
            
            # Color code efficiency
            if (( $(echo "$efficiency >= 90" | bc -l) )); then
                eff_color=$GREEN
            elif (( $(echo "$efficiency >= 70" | bc -l) )); then
                eff_color=$YELLOW
            else
                eff_color=$RED
            fi
            
            printf "%-2s | %-5s | %-7s | %-6s | ${eff_color}%-10s${NC} | %-8s | %s\n" \
                "$worker_id" "$total" "$completed" "$failed" "${efficiency}%" "$restarts" "$status"
        done
    fi
    
    echo ""
}

# Show task timeline
show_timeline() {
    echo -e "${CYAN}=== Task Timeline (Last 24 Hours) ===${NC}"
    echo ""
    
    local cutoff=$(date -u -d "24 hours ago" +%Y-%m-%dT%H:%M:%SZ)
    
    # Combine completed and failed tasks
    {
        [ -f "$COMPLETED_FILE" ] && awk -F'|' -v cutoff="$cutoff" '$7 > cutoff {print $7"|completed|"$2"|"$3"|"$5}' "$COMPLETED_FILE"
        [ -f "$FAILED_FILE" ] && awk -F'|' -v cutoff="$cutoff" '$7 > cutoff {print $7"|failed|"$2"|"$3"|"$5}' "$FAILED_FILE"
    } | sort -r | head -20 | while IFS='|' read -r timestamp status parent subissue worker; do
        local time_str=$(date -d "$timestamp" "+%H:%M:%S" 2>/dev/null || echo "$timestamp")
        
        if [ "$status" = "completed" ]; then
            echo -e "${GREEN}✓${NC} $time_str - #$subissue (parent: #$parent) - Worker: $worker"
        else
            echo -e "${RED}✗${NC} $time_str - #$subissue (parent: #$parent) - Worker: $worker"
        fi
    done
}

# Analyze bottlenecks
analyze_bottlenecks() {
    echo -e "${CYAN}=== Performance Analysis ===${NC}"
    echo ""
    
    # Check for slow tasks
    echo -e "${YELLOW}Potential Issues:${NC}"
    
    # Workers with high failure rates
    if [ -f "$METRICS_FILE" ]; then
        jq -r '.workers | to_entries[] | 
            select((.value.tasks_failed // 0) > (.value.tasks_completed // 0) * 0.3) |
            "• Worker \(.key) has high failure rate (\(.value.tasks_failed) failures)"' "$METRICS_FILE"
    fi
    
    # Workers with many restarts
    if [ -f "$METRICS_FILE" ]; then
        jq -r '.workers | to_entries[] | 
            select((.value.restarts // 0) > 3) |
            "• Worker \(.key) has been restarted \(.value.restarts) times"' "$METRICS_FILE"
    fi
    
    # Check queue backup
    local pending=$(grep -c "|pending||" "$QUEUE_DIR/queue.txt" 2>/dev/null || echo 0)
    if [ $pending -gt 10 ]; then
        echo "• Queue backup detected: $pending tasks pending"
    fi
    
    echo ""
    echo -e "${GREEN}Recommendations:${NC}"
    
    # Scaling recommendation
    if [ $pending -gt 10 ]; then
        local current_workers=$(jq -r '.workers | length' "$METRICS_FILE" 2>/dev/null || echo 0)
        local recommended=$((current_workers + (pending / 5)))
        echo "• Consider scaling to $recommended workers (currently: $current_workers)"
    fi
    
    # Restart recommendation
    if [ -f "$METRICS_FILE" ]; then
        local unhealthy=$(jq -r '.workers | to_entries[] | 
            select(.value.status != "alive" and .value.status != "healthy") | .key' "$METRICS_FILE" | wc -l)
        if [ $unhealthy -gt 0 ]; then
            echo "• $unhealthy workers need attention"
        fi
    fi
}

# Export metrics to CSV
export_csv() {
    local output_file="${1:-worker-metrics.csv}"
    
    echo "Worker ID,Tasks Completed,Tasks Failed,Total Tasks,Efficiency %,Restarts,Current Status" > "$output_file"
    
    if [ -f "$METRICS_FILE" ]; then
        jq -r '.workers | to_entries[] | 
            "\(.key),\(.value.tasks_completed // 0),\(.value.tasks_failed // 0),\((.value.tasks_completed // 0) + (.value.tasks_failed // 0)),\(((.value.tasks_completed // 0) / ((.value.tasks_completed // 0) + (.value.tasks_failed // 0) + 0.001)) * 100 | floor),\(.value.restarts // 0),\(.value.status // "unknown")"' \
            "$METRICS_FILE" >> "$output_file"
    fi
    
    echo "Metrics exported to: $output_file"
}

# Real-time monitoring
monitor_performance() {
    while true; do
        clear
        generate_report
        echo ""
        echo -e "${MAGENTA}=== Real-time Activity ===${NC}"
        echo ""
        
        # Show recent completions
        if [ -f "$COMPLETED_FILE" ]; then
            echo "Recent Completions:"
            tail -5 "$COMPLETED_FILE" | while IFS='|' read -r priority parent sid status worker created completed_at; do
                echo "  ✓ #$sid completed by $worker"
            done
        fi
        
        echo ""
        echo "Press Ctrl+C to exit"
        sleep 5
    done
}

# Main command handling
case "${1:-report}" in
    report)
        generate_report
        ;;
    
    timeline)
        show_timeline
        ;;
    
    analyze)
        generate_report
        echo ""
        analyze_bottlenecks
        ;;
    
    monitor)
        monitor_performance
        ;;
    
    export)
        export_csv "${2:-worker-metrics.csv}"
        ;;
    
    efficiency)
        if [ -n "$2" ]; then
            echo "Worker $2 efficiency: $(get_worker_efficiency $2)%"
        else
            echo "Usage: worker-performance efficiency WORKER_ID"
        fi
        ;;
    
    *)
        echo "Usage: worker-performance <command> [args]"
        echo ""
        echo "Commands:"
        echo "  report             - Generate performance report"
        echo "  timeline           - Show task completion timeline"
        echo "  analyze            - Analyze performance and bottlenecks"
        echo "  monitor            - Real-time performance monitoring"
        echo "  export [file]      - Export metrics to CSV"
        echo "  efficiency ID      - Get specific worker efficiency"
        echo ""
        echo "This tool analyzes worker performance metrics and provides"
        echo "insights to optimize the parallel development system."
        ;;
esac