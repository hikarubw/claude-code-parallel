#!/bin/bash
# Worker pool management tool for subissue-based system

WORKER_DIR="$HOME/.claude/workers"
STATE_FILE="$WORKER_DIR/state.json"
LOG_DIR="$WORKER_DIR/logs"
WORKTREE_BASE="$HOME/worktrees"

# Ensure directories exist
mkdir -p "$WORKER_DIR" "$LOG_DIR"

# Get repository info
REPO_PATH=$(git rev-parse --show-toplevel 2>/dev/null || pwd)
REPO_NAME=$(basename "$REPO_PATH")

# Worker loop script that will run in each tmux session
create_worker_loop() {
    cat << 'EOF'
#!/bin/bash
WORKER_ID=$1
LOG_FILE="$HOME/.claude/workers/logs/worker-${WORKER_ID}.log"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

log "Worker $WORKER_ID started"

while true; do
    # Get next item from queue
    NEXT_ITEM=$($HOME/Documents/repo/claude-code-tools/tools/queue next "worker-$WORKER_ID")
    
    if [ -z "$NEXT_ITEM" ]; then
        log "Queue empty, waiting..."
        sleep 30
        continue
    fi
    
    # Parse queue item
    PRIORITY=$(echo "$NEXT_ITEM" | cut -d'|' -f1)
    PARENT_ISSUE=$(echo "$NEXT_ITEM" | cut -d'|' -f2)
    SUBISSUE_ID=$(echo "$NEXT_ITEM" | cut -d'|' -f3)
    
    log "Processing subissue #$SUBISSUE_ID (parent: #$PARENT_ISSUE)"
    
    # Create worktree
    BRANCH="subissue/$SUBISSUE_ID"
    WORKTREE_PATH="$HOME/worktrees/subissue-$SUBISSUE_ID"
    
    # Clone worktree
    cd $(git rev-parse --show-toplevel)
    if git worktree add "$WORKTREE_PATH" -b "$BRANCH" origin/main; then
        log "Created worktree at $WORKTREE_PATH"
        
        # Work on subissue
        cd "$WORKTREE_PATH"
        
        # Run Claude to work on the subissue
        log "Starting Claude session for subissue #$SUBISSUE_ID"
        
        # Get Claude path
        CLAUDE_PATH=$(command -v claude || echo "/opt/homebrew/bin/claude")
        
        # Create initial prompt for Claude
        PROMPT="I need you to work on subissue #$SUBISSUE_ID which is part of parent issue #$PARENT_ISSUE.

First, fetch the subissue details using:
gh issue view $SUBISSUE_ID

Then implement the required changes according to the subissue description and acceptance criteria.

After implementation:
1. Run all tests to ensure nothing is broken
2. Commit your changes with a descriptive message
3. Create a pull request with:
   - Title: '[Subissue #$SUBISSUE_ID] <description>'
   - Body mentioning: 'Closes #$SUBISSUE_ID' and 'Part of #$PARENT_ISSUE'

Work autonomously and create the PR when done."

        # Run Claude
        echo "$PROMPT" | $CLAUDE_PATH
        
        # Update queue status
        $HOME/Documents/repo/claude-code-tools/tools/queue update "$SUBISSUE_ID" "completed" "worker-$WORKER_ID"
        
        # Cleanup worktree
        cd ..
        git worktree remove "$WORKTREE_PATH" --force
        
        log "Completed subissue #$SUBISSUE_ID"
    else
        log "Failed to create worktree for subissue #$SUBISSUE_ID"
        $HOME/Documents/repo/claude-code-tools/tools/queue update "$SUBISSUE_ID" "failed" "worker-$WORKER_ID"
    fi
    
    # Brief pause before next task
    sleep 5
done
EOF
}

# Start workers
start_workers() {
    local count="${1:-4}"
    
    echo "🚀 Starting $count workers..."
    
    # Create worker loop script
    local loop_script="$WORKER_DIR/worker-loop.sh"
    create_worker_loop > "$loop_script"
    chmod +x "$loop_script"
    
    # Start tmux sessions
    for i in $(seq 1 "$count"); do
        if tmux has-session -t "worker-$i" 2>/dev/null; then
            echo "⚠️  Worker $i already running"
        else
            tmux new-session -d -s "worker-$i" -c "$REPO_PATH" \
                "$loop_script $i"
            echo "✅ Started worker-$i"
        fi
    done
    
    # Save state
    echo "{\"worker_count\": $count, \"started_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}" > "$STATE_FILE"
    
    echo ""
    echo "Workers started! Monitor with: worker status"
}

# Stop workers
stop_workers() {
    local count="${1:-all}"
    
    if [ "$count" = "all" ]; then
        echo "🛑 Stopping all workers..."
        for session in $(tmux ls 2>/dev/null | grep "^worker-" | cut -d: -f1); do
            tmux kill-session -t "$session" 2>/dev/null
            echo "✅ Stopped $session"
        done
    else
        echo "🛑 Stopping $count workers..."
        local stopped=0
        for i in $(seq 1 100); do
            if tmux has-session -t "worker-$i" 2>/dev/null; then
                tmux kill-session -t "worker-$i"
                echo "✅ Stopped worker-$i"
                ((stopped++))
                [ $stopped -eq $count ] && break
            fi
        done
    fi
}

# Add more workers
add_workers() {
    local count="${1:-1}"
    
    echo "➕ Adding $count workers..."
    
    # Find highest worker number
    local max_worker=0
    for session in $(tmux ls 2>/dev/null | grep "^worker-" | cut -d: -f1); do
        local num=$(echo "$session" | sed 's/worker-//')
        [ $num -gt $max_worker ] && max_worker=$num
    done
    
    # Start new workers
    local loop_script="$WORKER_DIR/worker-loop.sh"
    if [ ! -f "$loop_script" ]; then
        create_worker_loop > "$loop_script"
        chmod +x "$loop_script"
    fi
    
    for i in $(seq $((max_worker + 1)) $((max_worker + count))); do
        tmux new-session -d -s "worker-$i" -c "$REPO_PATH" \
            "$loop_script $i"
        echo "✅ Started worker-$i"
    done
}

# Show worker status
worker_status() {
    echo "👷 Worker Pool Status"
    echo "==================="
    echo ""
    
    # Count workers
    local total=0
    local idle=0
    local working=0
    
    for session in $(tmux ls 2>/dev/null | grep "^worker-" | cut -d: -f1 | sort -V); do
        ((total++))
        
        # Get last line from worker
        local last_line=$(tmux capture-pane -t "$session" -p 2>/dev/null | tail -1)
        local status="unknown"
        
        if echo "$last_line" | grep -q "Queue empty"; then
            status="idle"
            ((idle++))
        elif echo "$last_line" | grep -q "Processing subissue"; then
            status="working"
            ((working++))
        elif echo "$last_line" | grep -q "Starting Claude"; then
            status="working"
            ((working++))
        fi
        
        printf "%-12s %s\n" "$session:" "$status"
        
        # Show current task if working
        if [ "$status" = "working" ]; then
            local task_info=$(echo "$last_line" | grep -o "#[0-9]*" | head -1)
            [ -n "$task_info" ] && printf "%-12s └─ %s\n" "" "$task_info"
        fi
    done
    
    echo ""
    echo "Summary: $total workers ($working working, $idle idle)"
}

# Show worker logs
worker_logs() {
    local worker_id="$1"
    local lines="${2:-20}"
    
    if [ -z "$worker_id" ]; then
        echo "Usage: worker logs WORKER_ID [LINES]"
        return 1
    fi
    
    local log_file="$LOG_DIR/worker-${worker_id}.log"
    
    if [ -f "$log_file" ]; then
        echo "📋 Last $lines lines from worker-$worker_id:"
        echo "======================================="
        tail -n "$lines" "$log_file"
    else
        echo "❌ No log file found for worker-$worker_id"
    fi
}

# Attach to worker session
worker_attach() {
    local worker_id="$1"
    
    if [ -z "$worker_id" ]; then
        echo "Usage: worker attach WORKER_ID"
        return 1
    fi
    
    if tmux has-session -t "worker-$worker_id" 2>/dev/null; then
        echo "📎 Attaching to worker-$worker_id (detach with Ctrl-B D)..."
        sleep 1
        tmux attach-session -t "worker-$worker_id"
    else
        echo "❌ Worker-$worker_id not found"
    fi
}

# Health check workers
worker_health() {
    echo "🏥 Checking worker health..."
    echo ""
    
    for session in $(tmux ls 2>/dev/null | grep "^worker-" | cut -d: -f1); do
        local worker_num=$(echo "$session" | sed 's/worker-//')
        local log_file="$LOG_DIR/worker-${worker_num}.log"
        
        if [ -f "$log_file" ]; then
            local last_activity=$(stat -f %m "$log_file" 2>/dev/null || stat -c %Y "$log_file" 2>/dev/null)
            local now=$(date +%s)
            local idle_time=$((now - last_activity))
            
            if [ $idle_time -gt 3600 ]; then
                echo "⚠️  $session: No activity for $((idle_time / 60)) minutes"
            else
                echo "✅ $session: Healthy"
            fi
        else
            echo "❓ $session: No log file"
        fi
    done
}

# Resume work after interruption
worker_resume() {
    echo "🔄 Resuming worker pool..."
    
    if [ -f "$STATE_FILE" ]; then
        local worker_count=$(jq -r .worker_count "$STATE_FILE" 2>/dev/null || echo 4)
        start_workers "$worker_count"
    else
        echo "No previous state found. Starting with 4 workers..."
        start_workers 4
    fi
}

# Main command handling
case "${1:-status}" in
    start)
        shift
        start_workers "$@"
        ;;
    
    stop)
        shift
        stop_workers "$@"
        ;;
    
    add)
        shift
        add_workers "$@"
        ;;
    
    status)
        worker_status
        ;;
    
    logs)
        shift
        worker_logs "$@"
        ;;
    
    attach)
        shift
        worker_attach "$@"
        ;;
    
    health)
        worker_health
        ;;
    
    resume)
        worker_resume
        ;;
    
    *)
        echo "Usage: worker <command> [args]"
        echo ""
        echo "Commands:"
        echo "  start [COUNT]      - Start COUNT workers (default: 4)"
        echo "  stop [COUNT|all]   - Stop COUNT workers or all"
        echo "  add [COUNT]        - Add COUNT more workers"
        echo "  status             - Show worker status"
        echo "  logs WORKER [N]    - Show last N lines from worker log"
        echo "  attach WORKER      - Attach to worker session"
        echo "  health             - Check worker health"
        echo "  resume             - Resume previous worker configuration"
        echo ""
        echo "Examples:"
        echo "  worker start 8           # Start 8 workers"
        echo "  worker add 4            # Add 4 more workers"
        echo "  worker logs 3 50        # Show last 50 lines from worker-3"
        echo "  worker attach 2         # Attach to worker-2 session"
        ;;
esac